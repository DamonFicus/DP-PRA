创建和销毁对象
    1.使用静态工厂代替使用构造器：
        a.可以自定义描述用合适来方法名来描述当前生成对象的背景和目的
        b.将创建对象统一进行规范，不用每次使用的时候又要重新去创建，同时可以避免对象过多造成的系统资源浪费
        c.灵活性，可以统一在创建的时候做一些添加额外的统一处理逻辑，而不必在分散的创建代码中进行追加，另外，静态工厂方法可以返回
        　原返回类型的任何子类型对象

    2.遇到多个构造器参数时，考虑使用构建器　
    3.使用私有构造器或者枚举强化Singleton属性
    4.通过私有构造器强化不可实例化能力
    5.避免创建不必要的对象
          例如　String s ="abc"的正常场景，被处理成String s = new String("abc") 就完全是不必要的，
          只是增加了内存空间的资源浪费；
    6.消除过期对象的引用
          对于某些资源使用完成后，要关闭；
          对于某些对象资源，使用完成后，将引用置为null可以让问题显现出来，否则，对于内在泄漏的问题，不能被JVM垃圾回收清理，可能会导致内存不足造成的磁盘交换
          Disk Paging 甚至是outofMemoryError

    7.避免使用终结方法

对于所有对象都通用的方法
    1.覆盖equals时遵守通用约定：
    2.覆盖equals时总是覆盖hashCode方法
    　equals相同的两个对象的hashCode一定是相同的，而hashCode相同的两个对象并不一定equals,正常情况下，不同的对象HashCode也不一样，表示得到了很好的散列，但是散列只是保证尽可能的将
      对象存放在不同的地址空间上去，提高空间的利用率，算法并不能保证百分之百都能散列到恰到好处的位置上；
    3.始终要覆盖toString
    4.谨慎地覆盖clone
    5.考虑实现comparable接口
    　comparable接口与comparator接口比较
    　1.comparable接口覆盖compareTo方法，而comparator接口覆盖compare方法
    　2.一个是比较接口，相当于提供比较属性，实现了comparable接口的对象都可以拿来进行比较，而comparator接口则是比较器接口，对于不具备排序能力，或对于特定排序时，给一个定义的排序规则来特殊处理时
    用到，使用comparable接口更加的常规和普遍；


类和接口
    1.使类和成员的可访问性最小化
    2.在仅有域中使用访问方法而非公有域
    3.使可变性最小化
    4.复合优先于继承
    5.要么为继续而设计，并提供文档说明，要么就禁止继承
    6.接口优先于抽象类
    7.接口只用于定义类型
    8.类层次优于标签
    9.用函数对象表示策略
    10.优先考虑静态成员类


泛型
    1.不要在代码中使用原生态类型
        比如Collection,不带类型的List,往往会把类型问题隐藏起来，在编译阶段不能被及时发现，而在运行阶段因为类型问题而发生异常
    2.消除非受检警告
    3.列表优先于数组
    4.优先考虑泛型
    5.优先考虑泛型方法
    6.利用有限制通配符来提升API的灵活性
    7.优先考虑类型安全的异构容器

枚举和注解
    1.用enum代替int常量
    2.用实例域代替序数
    3.用EnumSet代替位域
    4.用EnumMap代替序数索引
    5.用接口模拟可伸缩的枚举
    6.注解优先于命名模式
    7.坚持使用Override注解
    8.用标记接口定义类型

方法

通用程序设计


异常


并发


序列化