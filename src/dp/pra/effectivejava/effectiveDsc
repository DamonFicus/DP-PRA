创建和销毁对象
    1.使用静态工厂代替使用构造器：
        a.可以自定义描述用合适来方法名来描述当前生成对象的背景和目的
        b.将创建对象统一进行规范，不用每次使用的时候又要重新去创建，同时可以避免对象过多造成的系统资源浪费
        c.灵活性，可以统一在创建的时候做一些添加额外的统一处理逻辑，而不必在分散的创建代码中进行追加，另外，静态工厂方法可以返回
        　原返回类型的任何子类型对象

    2.遇到多个构造器参数时，考虑使用构建器　
    3.使用私有构造器或者枚举强化Singleton属性
    4.通过私有构造器强化不可实例化能力
    5.避免创建不必要的对象
          例如　String s ="abc"的正常场景，被处理成String s = new String("abc") 就完全是不必要的，
          只是增加了内存空间的资源浪费；
    6.消除过期对象的引用
          对于某些资源使用完成后，要关闭；
          对于某些对象资源，使用完成后，将引用置为null可以让问题显现出来，否则，对于内在泄漏的问题，不能被JVM垃圾回收清理，可能会导致内存不足造成的磁盘交换
          Disk Paging 甚至是outofMemoryError

    7.避免使用终结方法

对于所有对象都通用的方法
    1.覆盖equals时遵守通用约定：
    2.覆盖equals时总是覆盖hashCode方法
    　equals相同的两个对象的hashCode一定是相同的，而hashCode相同的两个对象并不一定equals,正常情况下，不同的对象HashCode也不一样，表示得到了很好的散列，但是散列只是保证尽可能的将
      对象存放在不同的地址空间上去，提高空间的利用率，算法并不能保证百分之百都能散列到恰到好处的位置上；
    3.始终要覆盖toString
    4.谨慎地覆盖clone
    5.考虑实现comparable接口
    　comparable接口与comparator接口比较
    　1.comparable接口覆盖compareTo方法，而comparator接口覆盖compare方法
    　2.一个是比较接口，相当于提供比较属性，实现了comparable接口的对象都可以拿来进行比较，而comparator接口则是比较器接口，对于不具备排序能力，或对于特定排序时，给一个定义的排序规则来特殊处理时
    用到，使用comparable接口更加的常规和普遍；


类和接口
    1.使类和成员的可访问性最小化
    2.在仅有域中使用访问方法而非公有域
    3.使可变性最小化
    4.复合优先于继承
    5.要么为继续而设计，并提供文档说明，要么就禁止继承
    6.接口优先于抽象类
    7.接口只用于定义类型
    8.类层次优于标签
    9.用函数对象表示策略
    10.优先考虑静态成员类


泛型
    1.不要在代码中使用原生态类型
        比如Collection,不带类型的List,往往会把类型问题隐藏起来，在编译阶段不能被及时发现，而在运行阶段因为类型问题而发生异常
    2.消除非受检警告
    3.列表优先于数组
    4.优先考虑泛型
    5.优先考虑泛型方法
    6.利用有限制通配符来提升API的灵活性
    7.优先考虑类型安全的异构容器

枚举和注解
    1.用enum代替int常量
    2.用实例域代替序数
    3.用EnumSet代替位域
    4.用EnumMap代替序数索引
    5.用接口模拟可伸缩的枚举
        即本来是在枚举的判断分支执行的某些逻辑，可以通过枚举类实现接口，在接口中做扩展
        A枚举定义了方法M1,M2,M3，而我现在需要M4方法，那么可以定义一个B枚举来实现与A相同的扩展接口
        然后在B中扩展M4方法；
    6.注解优先于命名模式
    7.坚持使用Override注解
    8.用标记接口定义类型

方法
    1.检查参数的有效性
    2.必要时进行保护性拷贝
    3.谨慎设计方法签名
    4.慎用重载
    5.慎用可变参数
    6.返回零长度数组或集合，而不是null
    7.为所有的导出API元素编写注释文档

通用程序设计
    1.将局部变量的作用域最小化
    2.for-each循环优先于传统的for循环
    3.了解和使用类库
    4.如果需要精确的答案，避免使用float和double
    5.基本类型优先于装箱基本类型
    6.如果其他类型更加适合，避免使用字符串
    7.当心字符串连接的性能
    8.通过接口引用对象
    9.接口优先于反射机制
    10.谨慎地使用本地方法
    11.谨慎地进行优化
    12.遵守普遍接受的命名惯例

异常
    1.只针对异常的情况和使用异常
    2.对可恢复的情况使用受检异常，对编程错误使用运行时异常
    3.避免使用不必要的受检异常
    4.优先使用标准的异常
    5.抛出与抽象相对应的异常（有时候需要进行异常转译，抛出一个被高层抽象能够理解的异常）
    6.每个方法抛出的异常都要有文档
        使用annotation进行异常标记
    7.在细节消息中包含能捕获失败的信息
    8.努力使失败保持原子性
        1.在执行操作之前检查参数有效性，在执行更改之前就将异常展现出来
        2.调整处理或执行的顺序，使任何可能失败的计算部分在修改部分之前发生，防止异常而又导致修改的副作用；
    9.不要忽略异常

并发
    1.同步访问共享的可变数据
    2.避免过度同步
    3.executor和task　优先于线程
    4.并发工具优先于notify和wait
    5.线程安全性的文档化
    6.慎用延迟初始化
    7.不要依赖于线程调度器
    8.避免使用线程组

序列化
    1.谨慎的实现Serializable接口

        在网络中以流形式进行传输的对象需要做序列化，序列化时，如果不指定序列化serialVersionUID，会有什么样的影响？
        UID是用来解决类似这种场景：
            A对象包含B对象的引用，在序列化的时候，会将B的数据复制一份在A中，这样在使用文件恢复对象，将对象加载到内存的
            过程中，如果B对象在内存中已经存在了，则会多出一个B出现在内存中，这是不合理的，所以使用UID来标识，保存到磁盘的
            所有对象都获得一个序列号，然后当要保存一个新对象时，会先检查该对象是否已经保存了，如果之前保存过，则只需要写入
            “已保存具有X序列号的对象”相同的标记，否则保存该对象，这样就能解决引用的序列化问题；

        如果序列化的对象能够反序列化，那么他们的版本号一定是相同的

      　序列化会把私有成员也序列化进去；

        序列化版本号，如果序列版本号不一致，就会在反序列化的时候抛出异常，比如先序列化了一个001L的序列号对象A到内存中
        而后续代码改动序列号变为002L，没有更新缓存，另一端在反序列化的时候，会因为版本号不致抛出异常；
        ？？？同样的对象，序列号不同，在内存中是否会创建两个对象？
            类加载机制同名字节码Class文件只会加载一个，所以，接收方拿到的是还是老旧的A,进行反序列化的时候，还是用以前
        的A来进行代理对象创建，如果有新增的属性，则并不会包含在其中；

    2.考虑使用自定义的序列化形式
        当一个对象的物理表示法与它的逻辑数据内容有差别时，使用默认的序列化会有如下缺点：
        1.它使这个类的导出API永远的束缚在了该类的内部表示法上
        2.它会消耗过多的空间
        3.它会消耗过多的时间
        4.它会引起栈溢出（大量的属性作为一个集合存在于列表中时）

        transient瞬时变量，标识为临时数据，在序列化的时候，这部分属性不会参加序列化，会被丢弃；

        自定义序列化，可以通过重写私有writeObject和readObject来进行过滤
        其底层其实是在ObjectOutputStream　和ObjectInputStream的时候做处理；
        比如A对象a属性不想被序列化，那么readObject的时候，objectInputStream.defaultReadObject时
        objectInputStream.readInt()中做过滤；

    3.保护性的编写readObject方法
    4.对于实例控制，枚举类型优先于readResolve

        readResolve方法是用JDK用来解决单例序列化问题，反序列化导致多个单例对象出现的解决方案
        反序列化时，如果对象中有readResolve方法那么它必定会被调用，并且返回用户指定的对象；
        这样可以保证内存中，返回的还是原来的单例对象；


    5.考虑使用序列化代理代替序列化实例



