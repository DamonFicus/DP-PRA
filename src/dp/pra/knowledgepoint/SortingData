梳理：
一、梳理业务结构；


二、梳理框架结构；


三、项目管理相关；


四、行业能用问题场景的解决方案；


五、对于难以发现和解决的BUG的处理经验和分析过程；


##############################################################################################

指导思想-方法论：

目的：为了梳理碎片知识结构-给孤立的知识找到组织
建立联结，方便提取和再加工

如何建立联系，产生关联？

元素与元素之间的关联;
元素与结构之间的关联；
结构与系统之间的关联；
系统与外部环境之间的关联；

有道无术，术尚可求；有术无道，止于术

道法术势器


抽象演绎综合分析


1.整理原则：MECE(Mutually Exclusive Collectively Exhaustive)  独立不重复，穷举无遗漏

2.描述&表达范式 SCQA(Situation情景，Complication冲突，Question疑问，Answer答案)

3.STAR(Situation背景，Target目标，Action行动，Result结果)

4.SWOT(Strengths优势，Weaknesses劣势，Opportunities机会，Threats威胁)

维度：

时间顺序 前中后，步骤顺序，事物发展顺序
结构顺序 空间、地理位置、（东西南北，上下左右）
程序顺序 轻重缓急，重要程度

金字塔原则



####################################################################################################

扩展笔记：
zookeeper的典型应用场景：
1.数据发布与订阅
2.负载均衡
3.命名服务
4.分布式协调/通知
5.集群管理
6.分布式锁
7.分布式队列

zk在大型分布式系统中的应用：
1.Hadoop
2.Hbase
3.Kafka

Dubbo


正则表达式


HeadFirst:
外观模式：
提供了一个统一的接口，用来访问子系统中的一群接口，
外观定义了一个高层接口，让子系统更容易使用。

使用组合让外观能够访问子系统中的所有组件
避免客户和子系统之间过紧的耦合；


策略模式
装饰器模式
模板方法模式
适配器模式
迭代器模式
工厂方法
命令模式
状态模式
代理模式


RMI远程调用：


模式是在某种情境下，针对某种问题的解决方案；

情景就是应用某个模式的情况，这应该是会不断出现的情况；
问题就是某情境下要达到的目标，或者是某情境下的约束；
解决方案就是：一个通用的设计，用来解决约束，达到目标；



定义模式：
名称
意图
动机
适用性
结构
参与者
协作


分类：
创建型
行为型
结构型


什么时候放弃使用模式:
当系统变得复杂，而且并不需要预留任何弹性的时候，即当前情境不会重复出现的时候
就不要使用模式；

只有在需要进行扩展和场景重复的时候，才会有模式使用的必要；

1设计模式入门欢迎来到设计模式世界
2观察者模式让你的对象知悉现况
3装饰者模式装饰对象
4工厂模式烘烤OO的精华
5单件模式独一无二的对象
6命令模式封装调用
7适配器模式与外观模式随遇模式
8模板方法模式封装算法
9选代器与组合模式管理良好的集合
10状态模式事物的状态
11代理模式控制对象访问
12复合模式模式中的模型
13与设计模式相处真实世界中的模式



TFS是成熟的软件开发管理系统，包括版本控制、发布管理、需求跟踪、文档发布等。
而相较而言，SVN只是源码的管理工具


装饰器模式是如何遵循开闭原则的？
装饰器通过组合的方式让原来的类功能得到增强，或添加额外的功能逻辑
处理能力，即使后续有新增，也可以再做包装，并不破坏开闭原则；


模板方法抽象定义算法骨架，具体由子类去实现具体的算法内容；
为防止恶意操作，一般模板方法都加上final关键字，防止模板骨架格式被子类恶意篡改；


综合评价：
设计模式


JVM原理和策略以及生产问题排查
例如内存泄漏或资源占用异常的情况分析；


kubernetes 自动化容器操作的开源平台，这些操作包括
部署，调度和节点集群扩展

docker只是kubernetes中的一个低级别组件；
kubernetes同时支持docker和rocket两种容器技术；

PREPARE

Spring Boot和Spring cloud之间的关系，
spring boot是骨架实现，spring cloud是更加复杂的应用扩展
spring boot可以离开spring cloud单独存在并且处理某些项目实现
但是spring cloud离不开spring boot;

spring 用于应用开发，而要实现完整的微服务框架，还需要服务注册与发现，API网关和负载等一些功能，就需要用spring cloud来实现框架中的这些功能；

项目经验
1.项目业务场景
2.项目技术选型
3.项目架构图，设计原则
4.

工作中遇到的问题
生产问题处理经验，如何发现，如何解决的过程；


整理面试题目；

RPC
dubbo源码
zookeeper源码和设计原理

网络IO
数据在七层结构中转换的过程，以及SSL,TCP的握手协议

操作系统
进程切换时间片

算法
时间复杂度
空间复杂度


项目管理和控制  整理《代码大全》中涉及到的内容
比如checklist


HashMap底层实现

redis缓存设计原理以及同类缓存产品比较的优缺点
同类产品横向对比，如memercached



B+树，索引实现的方式；

微服务的原理和应用

并发，分布式

画出工作中相关的系统的架构图;


设计框架图
生产部署图（拓扑）


jvm：
实现方案，思想
堆，清扫
引用记数器
copy 移动


<Thinking in Java>:
1.状态，行为，标识
调用方法，信息发送的过程
状态为对象结构，包括属性变量，
行为即方法调用，对象与对象之间的通信
标识，用内存中的地址来标识对象，

内存分配：堆，栈，方法区
	内存结构分布图

	Method Area   系统分配的一个内存逻辑区域，是JVM在装载类文件时，用于存储类型信息的（类的描述信息）
				  1.类的基本信息（类全限定名，直接超类的全限定名，类还是接口信息，访问修饰符，直接超接口的全限定名有序列表）
				  2.已装载类的详细信息	（运行时常量池，字段信息，方法信息）

	Heap 堆  RAM
	stack:	 RAM
		JVM stacks虚拟机栈，
		Native Method stacks本地方法发栈
	程序计数器

相关存储：

1.寄存器，位于CPU内，运行速度快，但是存储小
2.堆栈  RAM  自顶向下生长，指针上移，释放内存，指针下移，分配内存
3.堆    RAM

栈内存向下生长，和堆内存向上生长的原因是为了充分利用空闲的地址空间；

High address	stack
				  ↓

				  ↑
low  address     heap

如果stack是向上生长，heap也向上生长，那么边界怎么定呢? 如果固定给一个临界分界值，而有的程序栈空间占用得多，有的堆占用的多，这样
也会有浪费空间和溢出现像更多，所以两个相对开辟空间，这样更合理地分配内存；

stack 空间溢出就是 stack overflow
而heap溢出就是oom  out of memory

常量是与代码组织一起的，并不需要额外的存放和调取，所以速度快；

静态变量和全局变量是存放在静态区

全局变量的默认初始化：
数字类型 系统默认初始化为 0
boolean 系统默认初始化为 false
Char    系统默认初始人为 \u0000
引用类型的变量 统一初始化为 null



JVM调优调什么？减少GC频率，过多的GC会占用很多的系统资源影响吞吐量，特别是FULL GC 它会对整个堆进行整理;

主要手段，通过合理的分配JVM参数来提高垃圾回收的速度，合理分配堆内存的各部分的比例;如何调整？什么参数和比例是最合理的？

导致FULL GC的情况有哪些？
	1.旧生代空间不足
		调优时尽量让对象在新生代GC时被回收，让对象在新生代多存活一段时间，
		不要创建过大的对象和数组，避免直接在旧生代创建对象
	2.持久代空间不足
		增大Perm Gen空间，避免太多静态对象，控制好新生代和旧生代的比例，什么比例？
	3.system.gc()被显示调用；
		垃圾回收不要手动触发，依赖JVM自己清理机制去执行；



特性：封装，继承，多态



3.操作符

	算术运算符，赋值运算符，关系运算符，逻辑运算符，位运算符，条件运算符，扩展赋值运算符

	一元，二元，三元（自带条件判断，简化表达）

	不支持操作符重载 最接近重载现象的应该就是"+"对String的自动转换效果了

5.初始化清理：
	初始化的前后顺序：
	静态变量->静态初始化块->变量->初始化块->构造器


	类加载：
	java中类加载是动态加载的，在第一次使用这个类的时候才会加载它到内存，加载一个类时，查看其父类是否已经加载，如果没有
	则会先去加载父类；

	类加载的双亲委派模型：(由上到下依次加载，好处是，优先加载JDK的class，如果遇到已经存在的字节码，则不再重复加载
	                    这样做的好处可以避免截入与底层类同名的恶意代码)
	BootStrap Class Loader
	         |
	Extension Class Loader
	         |
	App       Class Loader
	         |
	Customer  Class Loader


6.访问权限控制：
    UML中对权限符的描述 private -
                      public  +
                      protected #
                      包访问权限 ～

    不同包相互之间的访问是private的，但是想要在一个类中组织不同的类，就需要导入包import，这样就可以直接进行访问了；
    类，就是一种类型，用来描述状态和行为的一组对象；


    虚拟机垃圾回收原理：
    	1.计数-清理 引用记数
    	2.停止-复制 stop-and-copy
    	3.标记-清扫 mark-and-sweep


7.复用类：

	复用类的两种常用方式：继承 is a 、组合 has a
	多使用组合而非继承
	将通用的东西抽象到上层

	final:(可修饰，类，变量，方法)
	对于类中的private方法，隐式的被指定为final，因为该方法是不能被覆盖的，而且子类也发现不了它的存在，无法取到它
	可以给private方法添加final修饰，但这并不增加任何额外的意义;

	复用方法：关于重载，区分重载的标准是参数类型或不同参数的参数顺序，而不能使用返回值来做为判断标准（因为在方法调用的地方，很多时候并不会关注返回值，这样就很难从写法上区分出来仅仅是返回区别的两个不同重载方法）


8.多态：
	是什么？
	是一种运行时自动根据实际情况执行子类逻辑的机制，好处是将实现隐藏，用通用的处理方式，来处理差异；
	将原本会耦合的场景代码进行解耦；

	组成部分？
    形式上：
	1.有继承
	2.有重写
	3.父类引用指向子类对象

	运行时多态，运行时，根据传入的实际类型去执行对应的方法；
	动态绑定，在执行类的实例方法时，先在子类中查找，找不到了再去找父类


9.接口理解成一种能力的描述规则;
	只关心是否能够提供这种能力，而不在意具体是什么类型；
	接口定义时，接口方法不需要加上访问修饰符，因为加不加都是public abstract;


10.内部类

   静态内部类
   成员内部类  不可以定义静态变量和方法，与初始化顺序有关，不可使用还未被初始化的对象和属性，
   方法内部类
   匿名内部类



11.
  value << num  左移num个单位，舍去最左边的位，右边空位补0， 相当于扩大2的num次方倍；
  value >> num  左移num个单位，舍去最右边的位，左边空位补0， 相当于缩小2的num次方倍；
  value >>> num 无符号右移
  没有<<< 这种运算符，因为左移都是补0，没有正负数的区别；


  关于日期工具类
  DateFormat
  SimpleDateFormat 均不是线程安全的；


  随机数的种子，作用是为了测试或验证方案可重复，比如指定了相同的随机种子，那么生成的随机数序列的顺序也是一致的，跟什么时候点，和在哪台机器上运行无关；
  随机数基于一个种子，种子固定，那么随机数的序列就是固定的，而不设置种子的随机数生成时，默认的构造方法会指定一个真正的随机数来执行运算，所以是一个不可
  重复的随机数序列；

HASH
    是为了更均匀的将对象散列，存放到内存中；
    对象默认的equals方法是比较地址，所以比较逻辑发生改变时，需要重写equals方法，
    而对于对象来说，相同对象hashcode一定相同，而不同对象，hashcode有可能相同；
    所以对于equals方法重写的时候，也需要对hashcode进行重写；
    hashcode的默认是将对象的内存地址通过hash算法转换成整数（因为哈希值是一个int类型的整数）
    一般来说，质数用于哈希会更好，不容易冲突，它只能被1和自己进行整除；

Random类是线程安全的，但是在并发很高的情况下，如果还是要使用随机，
则使用ThreadLocalRandom更合适；


12.异常

   异常发生时，会创建异常对象，然后交由异常处理机制进行处理，如果有在try catch中进行处理，则执行处理逻辑
   否则，直接中断程序的执行，并打印出相关的错误信息，异常调用链，则底向外层（调用层）进行错误信息输出；

   在实际生产中，异常日志的printStackTrace的底层是用System.err将错误信息打印输出到控制台，而
   System.err 和System.out 一样，输出的内容是可能被重定向的；

   所以生产中最好使用日志工具封闭的异常信息输出打印，而不要直接使用System.out.println()  e.printStackTrace;


   Throwable
      |-- Error      VirtualMachineError ： StackOverFlowError OutOfMemeryError

      |-- Exception  |--IOException  (checked exception)
      				 |--RuntimeException (unchecked exception)
      				 |--SQLException (checked exception)

    checked 和 unchecked 的区别：受检异常，JAVA会强制要求程序员进行处理，否则会有编译错误，而对于未受检异常
    则系统不做强制要求，也是不容易预测的产生错误的地方（编程逻辑错误），比如输入非法值，计算逻辑非法等；

    unchecked 异常 是RuntimeException的子类；

    对于自定义异常，是受检异常还是非受检异常，则要看自定义的异常类是继承自什么异常父类，如果继承自RuntimeException则
    为unchecked exception 如果继承自 受检的Exception 则是受检异常；

    throws 声明的都是checked exception 对于unchecked exception是不需要在方法处进行声明的；


13.字符串

	存储，字符串常量池
	+拼接时，底层其实还是使用数组将原数据进行了拷贝，生成了个新的字符串对象，如果常量池中已经存在，则不创建，直接使用；
	a.截断 suString  indexOf
	b.正则切割

	字符串拼接工具：StringBuffer StringBuilder




14.类型信息

    泛型的出现是为了类型安全，防止人为的加入错误的类型，但是编译时能正常通过，运行时由于类型问题导致转换失败，
    JAVA泛型实现，其实是类型擦除的，也就是底层统一认为是Object ，出来后再做强行转换
    编译器，编译的时候进行擦除，虚拟机运行的时候是无感知的，在它看来泛型和非泛型是没有区别的

    JDK1.7以后，泛型写法，new 后面的类型可以省略不写，编译器会自行进行推断；

	数组中只能存放基本类型的变量？为什么?
	String[] 数组来说String也非基本类型，数组是可以存放对象的， 只不过是持有对象的引用；

	集合中存放的对象（引用），而不能存放基本类型，如果是基本类型数据，要转为包装类存放，为什么？

	泛型可以对类进行修饰，也可以对方法进行修饰，泛型方法和泛型类没有关系，即正常的类里面也可以有泛型方法；


	上界A  extends A


	JAVA 通过两种方式在程序运行时发现和类型信息
	1.传统的RTTI(RunTime Type Identification 运行时类型定义)，假定我们在编译时已经知道了所有的类型
	2.通过反射机制，它允许在运行时发现和使用类信息；

	通配符比较：
	1.<? extends E> 用于灵活读取，使方法可以读取E或E的任意子类的容器对象，它们可以用类型参数的形式替代，但通配符形式更为简洁；
	2.<? super  E>  用于灵活写入或比较，使对象可以写入父类型的容器，使得父类型的比较方法可以应用于子类对象，它不能被类型形式参数所替代；

原因：
    对于以上第一种情况，我们知道的是，容器中是E和子类或E类型，那么，读取的时候，肯定是个E类型的，至于E1,还是E2,还是E3 都是E的类型；
    这种容器，不能直接写，是因为，放入的具体类型，不能确定是哪个类型，有可能是E1,E2,E3，所以这种情况下，放入不同的类型，到一个类型容器中
    是有隐患的，所以编译器，会拒绝这种情况的发生；
    容器：篮子
    类型: 水果子类，苹果，梨
    从蓝子里取，没问题，肯定都是水果， 但是要放，你不知道要放在哪号篮子里；所以适用读，不适用写


    对于第二种情况，因为操作的都是E的父类，那么，读的，是可以多种类型，是不能确定是哪种，这样，读出来也是类型不安全的
	它之所以可以写入，是因为当前的类型，肯定是满足条件的，就像往苹果篮，葡萄篮里，放水果，肯定是没有问题的，但是从不同的篮子里取
	就不能确保取的是对的水果；
	容器：篮子
	类型：苹果 梨 的父类 水果，食物
	从篮子里取，当前你知道的是水果，食物，那么你取的时候，你不知道取的是梨还是苹果，就不知道啥价格
	但是往里面放，可以随意放，因为都是水果；




PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super

	生产者使用extends
	如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成<? extends T>，比如List<? extends Integer>，因此你不能往该列表中添加任何元素。

	消费者使用super
	如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成<? super T>，比如List<? super Integer>，因此你不能保证从中读取到的元素的类型。

	即是生产者，也是消费者
	如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List<Integer>。


	泛型只能用于对象类型表述，而不能使用基本类型的原因是，类型擦除只会向上转为Oject进行处理，
	而基本类型不是对象，不能直接处理成Object;
	如果非要使用基本类型，则需要先将会基本类型处理成包装类对象，再使用泛型；


	泛型的局限：

	JAVA不支持泛型数组，
	如果要存放泛型对象，可以使用原始类型的数组，或泛型容器；
	泛型容器内部使用Object数组，如果要转型容器为对应类型的数组，需要使用反射；




迭代陷阱：

	在遍历的时候，调用容器的删除方法进行删除操作，比如在 foreach 循环中直接remove操作，会抛出ConcurrentModifycationException异常
	迭代器的内部会维护一些索引位置的相关数据，要求在迭代过程中，容器不能发生结构变化，否则这些索引位置就失效了，所谓结构性变化，是指增删
	元素，修改不算；

	对于这种场景，则需要使用迭代器的remove方法去处理，则不是直接使用容器的remove


HashMap初始长度16

   2的幂，而且是质数，哈希结果更均匀
   index = HashCode（Key） & （Length - 1）
hashmap是基于数组的，源码： transient Node<K,V>[] table;
table俗称hash桶（hash bin），将一个元素放到桶里时，不是像arraylist那样按顺序放，而是根据key的hash值来计算index。
这个时候就会产生hash碰撞，即如果算法不合法，key会大概率的计算到同一个index，从而使元素都放在同一个桶中。
为了减少哈希碰撞的几率，我们需要一个算法，该算法能让元素比较平衡的放到不同的桶中，
最简单的方式就是key.hash % table.length,为了效率，使用了位与&运算符。
源码中使用了tab[i = (n - 1) & hash]。当n=the power of 2时，n-1的二进制的后几位全是1，这时与操作更均匀；

HashMap中键值都可以为null，但HashTable中不能为空
对于不要求线程安全的非并发要求的场景下，使用HashMap，如果是高并发场景，则使用ConcurrentHashMap来实现；



Effective Java

创建和销毁对象
  考虑用静态工厂方法替代构造器
  遇到多个构造器参数时要考虑用构造器
  用私有构造器或者枚举类型强化Singleton属性
  通过私有构造器强化不可实例化的能力
  避免创建不必要的对象
  消除过期对象引用
  避免使用终结方法
对于所有对象都通用的方法
  覆盖equals时请遵守通用规定
  覆盖equals时总要覆盖hashcode方法
  始终要覆盖toString
  谨慎地覆盖clone
  考虑实现comparable接口
类和接口
  使类的成员可访问性最小化
  在公有类中使用访问方法而非公有域
  使可变性最小化
  复合优先于继承
  要么为继承而设计，并提供文档说明，要么禁止继承
  接口优先于抽象类
  接口只用于定义类型
  类层次优先于标签类
  用函数对象表示策略
  优先考虑表态成员类
泛型
  请不要在新代码中使用原生态类型
  消除非受检警告
  列表优先于数组
  优先考虑泛型
  优先考虑泛型方法
  利用有限制通配符来提升API的灵活性
  优先考虑类型安全的异构窗口
枚举和注解
  用enum代替int常量
  用实例域代替序数
  用EnumSet代替位域
  用enumMap代替序数索引
  用接口模拟可伸缩的枚举
  注解优先于命名模式
  坚持使用Override注解
  用标记接口定义类型
方法
  检查参数的有效性
  必要时进行保护性拷贝
  谨慎设计方法签名
  慎用重载
  慎用 可变参数
  返回零长度数组或集合，而不是null
  为所有的导出的API元素编写文档注释
通用程序设计
  将局部变量的作用域最小化
  for-each循环优先于传统的for循环
  了解和使用类库
  如果需要精确的答案，请避免使用float和double
  基本类型优先于装箱基本类型
  如果其他类型更适合，则尽量避免使用字符串
  当心字符串连接的性能
  通过接口引用对象
  接口优先于反射机制
  谨慎的使用本地方法
  谨慎的进行优化
  遵守普遍接受的命名惯例
异常
  对可恢复的情况使用受检异常，对编程错误使用运行时异常
  避免不必要的使用受检的异常
  优先使用标准的异常
  抛出与抽象相对应的异常
  每个方法抛出的异常要都要有文档
  在细节消息中包含能捕获失败的信息
  努力使失败保持原子性
  不要忽略异常
并发
  同步访问共享的可变数据
  避免过度的同步
  excutor和task优先于线程
  并发工具优先于wait和notify
  线程安全性的文档化
  慎用延迟初始化
  不要依赖于线程的调度器
  避免使用线程组
序列化
  谨慎地使用实现Serializable接口
  考虑使用自定义的序列化形式
  保护性的编写readObject方法
  对于实例控制，枚举类型优先于readResolve
  考虑用序列化代理代替序列化实例




模型-关联（信息通路）


































