《并发知识地图》
并发的需求场景
并发的解决方案
并发的优点和缺陷


volatile 作用是禁止指令重排
它并不对资源进行阻塞上锁，而是通过，循环比较，（compareAndSet 首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和譔 标志的值设置为给定的更新值）如果比较结果不一致，则继续循环，
并不会锁资源，所以相比Synchronized更加轻量；之所以没有取代更重的synchronized的原因
1.可以某些时候循环造成的开销大
2.只能保证一个共享变量的原子操作
3.ABA问题：A 和 B 线程都拿到共享变量 X的值，然后B线程对X做了修改成Y，后续又修改成了X，而对于线程A来说
你再去取值进行比较的时候，取到的仍然是X，对于它来说，这个变化的过程它是感知不到的；

可以用AtomicStampedReference来解决ABA的问题；



CAS compare and swap 比较然后变换
CAS 是多核的操作系统底层(原子指令)来进行保证的，是一种硬件对并发的支持，用于管理对共享数据的并发访问；
java并发包中的compareAndSwap方法调用的是JNI的代码，借助C来调用CPU底层指令实现，目的是比较内存中的值
this和expect是否一致，如果一致则将this修改为update并返回为true，通过这样的方式将内存中的值修改为update;


concurrent包的源码实现：通用的模式
1.首先，声明共享变量为volatile
2.然后，使用CAS原子条件更新来实现线程之间的同步
3.同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信；




对于非volatile变量，线程读取的时候：
内存-->CPU缓存
这种模式，对于有多个CPU的计算机，每个线程可能在不同的CPU上进行处理，则有可能拷贝到的是不同的值；
这个变量，在不同的线程之间，是相互不可见的；

用volatile修饰后，取值不再直接从缓存中取，而是强制去内存中取，这样一来，来源统一了以后，就保证了
值的内存可见性；同时，volatile修饰的变量，在不同的线程之间是可见的；


锁的可重入特性是什么？
首先要知道，锁是针对线程来说的，而不是每次的调用，所以
对于当前获取了锁的线程，是可以重新进入加锁了的区域的，这背后的实现机制就是：
通过为每个锁关联一个计数器，acquisition count和一个占有它的线程，当计数器为0时
认为锁是未被占用的，线程请求一个未被占用的锁时，JVM将记录锁的占有者，并且将请求计数置为1，
如果同一个线程再次请求这个锁，则加1递增，每次占用线程退出同步块，则减1，直到计数器变为0，锁被释放；


通常简单性和性能是相互牵制的，实现一个同步策略时，不要过早的为了性能而牺牲简单性；

有些耗时的计算或操作，比如网络或控制台IO,难以快速完成，执行这些操作期间不要占有锁；